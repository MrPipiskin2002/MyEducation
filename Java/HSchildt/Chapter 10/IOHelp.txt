#System.in

System.in - экземпляр подкласса InputStream
Поэтому для него доступны методы InputStream. Одним из которых является метод read(), имеющий три вариации:
 int read() throws IOException
 int read(byte[] data) throws IOException
 int read(byte[] data, int start, int max) throws IOException

int read() - читает один символ с клавиатуры, возвращает -1, при попытке чтения в конце потока
int read(byte[] data) - читает байты из входного потока введённых с клавиатуры и записывает их в массив data, пока
1) Не будет достигнут конец массива
2) Не будет достигнут конец потока
3) Не возникнет ошибка, 
возвращает число прочитанных символов, возвращает -1, при попытке чтения в конце потока
int read(byte[] data, int start, int max) - помещает входные данные в data, начиная с места start, может сохранить ДО max байтов, возвращает количество введённых символов или -1 при попытке чтения в конце потока
При возникновении исключения все версии генерируют исключение IOException.
...

#System.out

System.out - это поток байтовых данных
Можно понять, что консольный вывод основанный на потоке байтовых данных через System.out по-прежнему популярен.
Консольный вывод проще всего обеспечить с помощью методов print() и println()
Данные методы определены в классе PrintStream. (Тип ссылочной переменной и объекта на который ссылается System.out)
Пусть System.out является потоком байтовых данных, применять его для простого вывода приемлемо.
...

#PrintStream

PrintStream класс производный от OutputStream - представляет выходной поток, он реализует низкоуровневый метод write();
Таким образом, write() можно использовать для записи в консоль.
Вот простейшая форма write() определённая в PrintStream
write(int byteval)
Метод write записывает байт, указанный в аргументе byteval
Не смотря на то что входной тип int, записываются только младшие 8 битов
Метод write() удобен в ряде ситуаций, но 
значительно проще применять print() и println()

Класс PrintStream предлагает два дополнительных метода вывода:
printf();
format();
Они обеспечивают детальный контроль над ТОЧНЫМ форматом данных, которые выводятся.
Они позволяют указывать:
-Количество отображаемых десятичных разрядов
-Минимальную ширину поля
-Формат отрицательного значения
И т.д.
...

#FileInputStream

Файл открывается для ввода за счёт использования конструктора
FileInputStream (String filename) throws FileNotFoundException.
В параметр filename передаётся имя файла. Если файл с данным именем не найден, выбрасывается исключение FileNotFoundException, которое необходимо обработать.
Данное исключение является подклассом IOException
Для чтения из файла можно использовать метод read()
int read() throw IOException - метод читает один байт из файла и возвращает его в виде целочисленного значения, если достигнут конец файла, возвращается значение -1. При возникновении ошибки генерируется исключение IOException
При завершении работы с файлом его нужно закрыть
Для этого нужно вызвать метод close()
void close() throw IOException
При закрытии файла освобождаются системные ресурсы, которые использовались для работы с файлом
Эти ресурсы теперь можно использовать для работы с другим файлом.
Если не закрыть файл могут возникнуть "утечки памяти"
Они возникают из за того что неиспользуемые ресурсы остаются выделенными.
...

#FileOutputStream

Чтобы открыть файл для вывода понадобится создать объект FileOutputStream
Создание такого объекта обычно происходит с помощью двух популярных конструкторов:
FileOutputStream (String filename) throws FileNotFoundException
FileOutputStream (String filename, boolean append) throws FileNotFoundException
FileNotFoundException в данном случае выбрасывается, если создать данный файл не удается.
При использовании первого конструктора, файл с таким именем filename удаляется, если таковой существовал.
При использовании второго конструктора, если параметр append равен true, то вывод добавится в конец файла. Если append равен false - файл перезаписывается.
Для выполнения записи в файл, можно использовать метод write()
void write (int byteval) throws IOException
Этот метод записывает в файл один байт, указанный в аргументе byteval.
Хоть параметр и имеет тип int, записываются в файл все равно младшие 8 разрядов.
После выполнения записи файл необходимо закрыть
Осуществляется это с помощью вызова метода close()
...

#try_с_ресурсами

Способ закрытия потока через метод close() использовался с появления языка Java, его можно встретить в существующем коде, он по прежнему актуален и полезен.
Однако с версии JDK 7 появилось более рациональное средство управления ресурсами, наподобие файловых потоков.
Это средство автоматизирует процесс закрытия потоков.
Оно называется автоматическое управление ресурсами.
Это средство осуществляется через оператор try с ресурсами.
Форма оператора try с ресурсами:
try (спецификация-ресурса) {
//блок кода с использованием ресурса
}
Спецификация-ресурса - как правило, оператор, который объявляет и инициализирует ресурс, например файловый поток
Спецификация ресурса состоит из:
Объявления ссылочной переменной
Инициализации переменной ссылкой на управляемый объект.
Пример спецификации ресурса:
try (FileInputStream fin = new FileInputStream(args[0]))
В таком случае переменная fin будет локальной для блока try. При завершении работы блока try, будет неявно вызван метод close() и поток связанный с fin автоматически закроется. Ресурс объявленный в параметре try неявно является final. Область действия ресурса ограничена областью блока оператора try с ресурсами
Когда try заканчивается, ресурс автоматически освобождается.
Например, для файла это будет означать автоматическое закрытие файла после выхода из блока try.
Оператор try с ресурсами также может быть связан с конструкциями catch и finally.

Начиная с JDK 9 спецификация ресурса может быть переменной, которая была объявлена и инициализирована ранее в программе. Но эта переменная должна быть фактически финальной. (После инициализации, значение не меняется)

Оператор try с ресурсами применим только к ресурсам, которые реализуют интерфейс AutoClosable из java.lang
AutoClosable унаследован от Closable из java.io 
Оба интерфейса реализованы классами потоков.
try с ресурсами можно использовать при работе с потоками, включая файловые потоки.

Начиная с JDK 9 тип ресурса объявленного внутри оператора try с ресурсами можно выводить, то есть использовать ключевое слово var.
Пример:
try (var fin = FileInputStream(args[0])) {}

В одиночном операторе try можно управлять более чем одним ресурсом
Для этого достаточно отделять спецификации ресурсов через точку с запятой
Пример
try ((FileInputStream fin = new FileInputStream(args[0]);
FiliOutputStream fout = new FileOutputStream(args[1]))
По окончании блока fin и fout будут закрыты.

Существует ещё один механизм связанный с оператором try с ресурсами.
Если в классическом блоке try возникает исключение, то в блоке finally при закрытии файла может появиться другое исключение, а первое будет утрачено, будет вытеснено вторым исключением.
Если такая ситуация происходит в блоке try с ресурсами, то первое исключение будет не утрачено, а подавлено, оно будет добавлено в список подавленных исключений, которые ассоциированы с первым.
Получить данный список подавленных исключений можно вызвав метод getSupposed(); определённый в классе Throwable.
...

#DataInputStream/DataOutputStream
DataInputStream реализует интерфейс DataInput
DataOutputStream реализует интерфейс DataOutput
Интерфейс DataOutput определяет методы, которые записывают значения всех примитивных типов Java в файл
Интерфейс DataInput определяет методы для чтения значений примитивных типов Java из файла
При использовании записи двоичных данных в файл с помощью класса DataOutputStream следует понимать, что эти данные будут записаны в своём внутреннем двоичном формате, а не в удобной читаемой форме.
Часто применяемые методы вывода/ввода из классов DataOutputStream/DataInputSteam соответственно представлены в таблице
Каждый из этих методов в случае ошибки может генерировать исключение IOException.
Конструктор DataOutputStream:
DataOutputStream (OutputStream outputStream) - можно заметить, что тип ссылочной переменной параметра OutputStream, то есть любой поток являющийся подклассом OutputStream может быть потоком куда направляются двоичные данные.
Чтобы записать двоичные данные в файл можно использовать объект, созданный FileOutputStream для этого параметра.

Класс DataInputStream в качестве основы использует экземпляр InputStream, ??перекрывая?? этот экземпляр методами для чтения различных типо данных Java.
DataInputStream читает данные в двоичном формате а не в удобной читаемой форме
Конструктор DataInputStream
DataOutputStream (InputStream inputStream) - в inputStream так же указывается некоторый поток связанный с DataInputStream
Чтобы прочитать данные из файла можно использовать объект FileInputStream, созданный для этого параметра

Так будет выглядеть оператор try с ресурсами для обработки таких потоков:
try (DataOutputStream dataOut = new DataOutputStream(new FileOutputStream("testdata"))) 
try (DataIntputStream dataOut = new DataIntputStream(new FileIntputStream("testdata")))
...

#RandomAccessFile

Файлы с произвольным доступом.
До этого момента использовались классы для работы с файлами линейным образом (название: последовательные файлы) один байт за другим, для чтения или записи.
Однако в Java можно обеспечить произвольный доступ к файлу. Обращаться к его содержимому в произвольном порядке.
Это возможно с применением класса RandomAccessFile

ВАЖНО: Этот класс НЕ является производным от InputStream и OutputStream в отличие от множества других классов, обеспечивающих ввод-вывод.
Этот класс реализует интерфейсы DataInput и DataOutput

Вот так выглядит конструктор экземпляра этого класса:
RandomAccessFile(String fileName, String access) throws FileNotFoundException, где
fileName - имя файла
access - один из возможных типов доступа к файлу:
"r" - файл можно читать, но не записывать
"rw" - файл можно читать / записывать
"rws" и "rwd" (для локальных устройств) - немедленная запись изменений данных файла на физическое устройство. 

Для установки позиции в файле указателя используется метод seek()
void seek(long newPos) throws IOException, где 
newPos - новая позиция указателя (в байтах) считая от начала файла (То есть как я понял: какое количество байтов указано в newPos, столько шагов по записанным в файл байтов, сделает указатель, то есть 0 - начало файла, 1 - перешагнёт 1 байт и т.д.). Следующее чтение и запись будет осуществляться с новой позиции.

RandomAccessFile реализует интерфейсы DataInput, DataOutput, то есть для экземпляра этого класса доступны чтение и запись двоичных данных примитивных типов.
Также для RandomAccessFile реализованы методы read() и write() 

Замечание: если мы будем использовать методы, например writeDouble() readDouble(), то
по-скольку значения типа Double занимают 8 байтов, при работе с этим файлом и методом seek, небходимо ставить указатель на позиции каждого восьмого байта, то есть seek(8) seek(16), чтобы корректно извлекать информацию из файла.


Этот класс поддерживает запросы на позиционирование, то есть можно помещать указатель по запросу в определённое место
...

#BufferReader

Для кода, который планируется интернационализировать
Ввод с консоли с использованием потока символьных данных будет более удобным и эффективным способом чем применение потоков байтовых данных
Но System.in представляет поток байтовых данных
Поэтому его придётся поместить в класс оболочку некоторого типа Reader
Лучший класс для чтения ввода с консоли - BufferReader, он поддерживает буферизированный поток ввода
Конструктор этого класса: BufferReader (Reader inputReader)
Есть одно но, нельзя в этот конструктор напрямую поместить System.in. Поскольку System.in это поток производный от InputStream.
Поэтому сначала мы преобразуем System.in в поток символьных данных используя InputStreamReader.
С помощью конструктора получим объект InputStreamReader связанный с System.in
До JDK 17 это следовало делать с применением следующего конструктора:
InputStreamReader(InputStream inputStream), то есть
Ранее объект BufferReader, связанный с System.in создавался следующим образом:
BufferReader br = new BufferReader(new InputStreamReader(System.in)) 
Так мы получаем переменную br - символьный поток, связанный с консолью через System.in

Но с JDK 17 рекомендуется явно указывать набор символов ассоциированный с консолью
Набор символов определяет способ сопоставления байтов с символами
Когда набор символов не задан явно, применяется стандартная кодировка JVM
Но в случае консоли, набор символов для консольного ввода, может отличаться от стандартного набора
То есть теперь РЕКОМЕНДУЕТСЯ использовать следующую форму конструктора InputStreamReader
InputStreamReader(InputStream inputstream, Charest charest), где 
inputstream - поток некоторого подкласса InputStream
Charest - класс определяющий наборы символов
charest - конкретный набор символов, ассоциированный с консолью
Он возвращаетсяс с помощью метода charest() - метод из класса Console. метод был добавлен к классу в JDK 17
Объект Console получается с помощью вызова метода System.console()
Данный метод возвращает:
Ссылку на консоль
null - если консоль отсутствует 

Один из способов помещения System.in в оболочку BufferReader:
Console con = System.console();
if (con == null) return;
BufferReader  br = new BufferReader(new InputStreamReader(System.in, con.charest()));

Разумеется, если мы знаем что консоль присутствует, кодовую последовательность можно сократить:
BufferReader br = new BufferReader(new InputStreamReader(System.in, System.console.charest()));

— Таким образом, вот краткое описание, обработанное мной.
Для создания консольного символьного буферизированного потока лучшее средство - класс BufferReader
System.in напрямую нельзя поместить в конструктор данного класса, его сначала нужно обернуть в класс обработки символьных потоков.
Это делается с помощью InputStreamReader, рекомендуемо с уточнением символьного набора консоли
Так поток превращается в другой поток несколько раз:
System.in -> InputStreamReader -> BufferReader —

Символы можно читать из System.in с помощью метода read(), определённого в BufferReader, 
Почти также, как они читались с использованием потоков байтовых данных.
Вот три версии read() из BufferReader()
int read() throws IOException - читает символ Unicode, возвращает -1 при попытке чтения в конце потока
int read(char[] data) throws IOException - читает символы, помещает их в массив, пока не будет достигнут конец потока или не закончится массив, или не произойдёт ошибка
int read(char[] data, int start, int max) throws IOException - помещает символы в data, начиная с индекса start, сохраняет до max символов, если не будет достигнут конец потока, массива или не произойдёт ошибка. Вернёт количество прочитанных символов или -1 при попытке чтения в конце потока
Все версии метода read() генерируют исключение IOException

Как и с байтовыми потоками при чтении из консоли можно обрабатывать исключения IOException за пределами main:
public static void main(String[] args) throws IOException

Для чтения строки с консоли предназначен метод readLine(), который является членом BufferReader
Общая форма
String readLine() throws IOException
Вовращает объект строку String, которая соддержит прочитанные символы, а если предпринимается попытка чтения в конце потока возвращает null
...

#Console

Немного о классе Console:
Впервые класс появился в JDK 6
Применяется для чтения записи на консоль
Большая часть функциональности доступна через System.in, System.out
Этот класс может упростить некоторые типы взаимодействия с консолью, например при чтении строк с консоли

Конструкторы класса отсутствуют
Объект создаётся путём вызова метода System.console()
Если консоль доступна, на неё возвращается ссылка, если нет возвращается null
Консоль может быть доступна не всегда, например, когда программа выполняется как фоновая задача. То есть если возвращается null, консольный ввод-вывод НЕВОЗМОЖЕН
В нём определено несколько методов обеспечивающих ввод-вывод:
readLine() - чтение строки
printf() - форматный вывод
readPassword() - чтение текста без отображения вводимого текста
С JDK 17 доступен метод charest() - возвращает кодировку, которая использует консоль
Можно получить объекты Reader Writer подключенные к консоли
Применение Reader подключенного к Console, можно использовать как альтернативу помещения System.in в оболочку InputStreamReader
...

#PrintWriter

Консольный вывод с использованием символьных потоков
Использование System.out вполне допустимо, но лучше это делать для целей отладки программ
В реальных программах рекомендуется осуществлять вывод на консоль с помощью символьного потока PrintWriter - символьного класса
Использование символьного класса упрощает интернационализацию программы

В классе PrintWriter определено несколько конструкторов, один из них: 
PrintWriter(OutputStream outputStream boolean flushingOn)
flushingOn определяет будет ли автоматически очищаться буфер после использования метода println() (или других методов вывода). true - да, false - автоматического очищения буфера не будет.
PrintWriter поддерживает методы print() println(), их можно применять тем же способом, как они применялись с System.out
Если внутри метода будет содержаться непростой тип, то будет вызываться метод toString() объекта с отображением результата
Чтобы выполнить запись в консоль с PrintWriter нужно указать System.out для потока вывода с автоматической очисткой:
PrintWriter pw = new PrintWriter(System.out, true);

Нет ничего плохого в использовании System.out для вывода на консоль при отладке в учебных программах. PrintWriter в данном случае почти никогда не даст преимуществ.
Однако PrintWriter упрощает ??интернационализацию реальных приложений??
...

#FileReader/FileWriter

Файловый ввод-вывод с использованием символьных данных
Хотя обработка данных основанная на байтах является наиболее распространённой,
для этой цели можно применять потоки символьных данных
ГЛАВНОЕ ПРЕИМУЩЕСТВО: символьные потоки при работе с файлами используют непосредственно символы Unicode.
Если нам нужно хранить символы в файлах в формате Unicode, то лучше использовать потоки символьных данных.

Для выполнения файлового ввода-вывода на основе символов используются классы FileWriter и FileReader
FileWriter создаёт объект подкласса Writer, который можно применять для записи в файл
Конструкторы:
FileWriter(String filename) throws IOException
FileWriter(String filename, boolean append) throw IOException

filename - имя файла
append - булевый параметр, если true, выходные данные записываются в конец файла, если false, то файл полностью перезаписывается
Конструкторы способны гененерировать исключение IOException
FileWriter является классом производным от Writer и OutputStreamWriter
FileWriter имеет доступ к методам вышеупомяных классов

FileReader - класс создаёт объект, который можно использовать для чтения содержимого файла
Часто используемый конструктор FileReader:
FileReader(String filename) throws FileNotFoundException
FileReader является производным от InputStreamReader и Reader
FileReader имеет доступ к методам вышеупомянутых классов
Пример:
Для того чтобы читать содержимое файла и выводить его на консоль понадобится заключить объект FileReader в оболочку BufferedReader
BufferedReader br = new BufferedReader(new FileReader("text.txt"))
...

#NIO

Пакет ввода вывода NIO
NIO - new input/output пакет который поддерживает подход ввода-вывода на базе каналов
Классы NIO содержатся в пакете java.nio и его подчинённых пакетах java.nio.channels, java.nio.charset
Система NIO построена на двух фундаментальных элементах: Канал и буфер 
Канал - открытое подключение к устройству ввода-вывода, таким как файл или ??сокет??
Буфер - содержит данные
В общем случае сначала нужно получить канал к устройству ввода-вывода и буфер для хранения данных, затем можно работать с буфером, вводя или выводя данные

Другие две сущности NIO: набор символов и селекторы
Набор символов определяет способ сопоставления байтов и символов
С помощью кодировщика можно закодировать символы в байты
С помощью декодировщика можно декодировать байты в символы
Ну и в зависимости от набора символов кодировка и декодировка будут происходить по разному. Вернее алгоритм зачастую один, но результаты будут разные для разных наборов символов и одинакового набора байтов

??Селектор поддерживает неблокирующий мультиплексированный ввод-вывод на основе ключей??
Селекторы позволяют выполнять ввод-вывод по нескольким разным каналам
Обычно они применимы к каналам, которые поддерживают сокеты

В JDK 7 NIO была сильно улучшена
Были добавлены пакеты
java.nio.file
java.nio.file.attribute
java.nio.file.spi
Новые классы, интерфейсы, методы, поддержку потокового ввода-вывода
Значительно расширены возможности применения NIO особенно с файлами
NIO не заменяет классы java.io
Классы NIO предназначены для дополнения системы ввода-вывода,
Они предлагают альтернативный подход, который в некоторых обстоятельствах уместнее
...

#Scanner

Использование класса Scanner

Существует ещё один способ преобразования числовой строки в её внутренний двоичный формат
Он подразумевает использование одного из методов опредлённых в классе Scanner из пакета java.util
Класс Scanner читает удобочитаемые форматированные входные данные и преобразует их в двоичную форму
Класс можно использовать для чтения данных из разных источников в том числе консоль и файлы
Так, с помощью Scanner можно прочитать числовую строку введённую с клавиатуры, преобразовать и присвоить её значение переменной
Сначала необходимо создать экземпляр класса
Scanner(InputStream from);
from - поток используемый в качестве источника ввода
Конструктор для создания экземпляра Scanner, связанного с консольным вводом:
Scanner consoleIn = Scanner(System.in);
consoleIn после выполнения данной строки можно использовать для чтения консольного ввода с клавиатуры
для чтения числовых данных:
1) с помощью одного из методов hasNextX(); где X - некоторый тип требуемых данных, проверить доступен ли этот тип ввода. Примеры: hasNextInt(), hasNextDouble(). Данные методы и им подобные возвращают true если данные нужного типа являются следующими в потоке данных, иначе false
2) Если данные этого типа доступны их можно прочитать с помощью метода nextX(); где X некоторый тип требуемых данных. Примеры nextInt(), nextDouble(). Данные методы считывают упорядоченную удобочитаемую строку данных представленную в виде формы соответствующей некоторому типу, и преобразуют эту строку в двоичное представление этого значения, затем возвращают это значение.
Пример применения:
Scanner consoleIn = new Scanner(System.in);
int i;
if (consoleIn.hasNextInt())  i = consoleIn.nextInt();
Метод nextX можно вызвать без предварительного вызова hasNextX,
НО так делать не рекомендуется
Если методу nextX() не удастся найти тип искомых данных, он сгенерирует исключение InputMismatchException
Поэтому желательно сначала удостовериться в том, что значение запрашиваемого типа присутствует в потоке ввода.
...

#Оболочки_примитивных_типов

Оболочки типов для преобразования числовых строк
Известно, что метод println() автоматически преобразует числовые значения в удобочитаемую форму
read() не может читать строку содержащую значение числа и одновременно преобразовать её в внутренний двоичный формат числа типа int
Для такой задачи в Java предусмотрены другие способы. Например классы оболочки типов - классы, которые инкапсулируют примитивные типы, давая возможность примитивных типов использовать некоторый функционал объектов, такой как передача значения по ссылке.
В состав оболочек входят классы:
Integer, Long, Short, Byte, Character
Float, Double 
Boolean
Эти классы предлагают широкий набор методов, который позволяет полностью интегрировать примитивные типы в иерархию объектов
Эти классы также предоставляют функционал для преобразования числовой строки в соответствующий внутренний двоичный эквивалент

Методы синтаксического анализа предоставляют лёгкий способ преобразования числового значения введённого с клавиатуры из текстового файла, в надлежащий внутренний формат
Оболочки целочисленных типов, также предоставляют метод синтаксического анализа, который позволяет указывать систему счисления
Разнообразные механизмы хранения из библиотеки Java, такие как карты, списки, наборы, работают только с объектами
Чтобы сохранить значение int в одной из таких структур, его сначала нужно поместить внутрь объекта
Также все оболочки типов имеют методы:
compareTo() - сравнивает значение находящееся внутри оболочки
equals()  - проверяет два значения на предмет равенства
И методы возвращающее значение объекта в различных формах
Тема оболочек примитивных типах развивается в главе про автоупаковку
...

@
System.in, System.out, PrintStream, FileInputStream, FileOutputStream, try_с_ресурсами, DataInputStream/DataOutputStream, RandomAccessFile, BufferReader, Console, PrintWriter, FileReader/FileWriter, NIO, Scanner, Оболочки_примитивных_типов
